/*
	Researched by: SuperSaiyajinStackZ.
	Topic: AC:WW Letter Structure for Europe | USA, Japanese & Korean.
	Additional Note: EUR & USA are the same. EUR, USA, JPN uses the special encoding table, which is inside Encoding.research.
	Last edited date: November, 12th, 2020.
*/

/*
	PaperID enum class.

	The ID's for each paper are commented next to the name.
	I assume the indexes are like that. Confirmation will follow.
*/
enum class PaperIDs : uint8_t {
	Butterfly_Paper,	// 0x0.
	Airmail_Paper,		// 0x1.
	New_Years_Cards,	// 0x2.
	Lacy_Paper,			// 0x3.
	Cloudy_Paper,		// 0x4.
	Petal_Paper,		// 0x5.
	Snowy_Paper,		// 0x6.
	Maple_leaf_Paper,	// 0x7.
	Lined_Paper,		// 0x8.
	Notebook_Paper,		// 0x9.
	Flowery_Paper,		// 0xA.
	Polka_dot_Paper,	// 0xB.
	Bottle_Paper,		// 0xC.
	Ribbon_Paper,		// 0xD.
	Sparkly_Paper,		// 0xE.
	Vine_Paper,			// 0xF.
	Formal_Paper,		// 0x10.
	Snowman_Paper,		// 0x11.
	Card_Paper,			// 0x12.
	Leopard_Paper,		// 0x13.
	Cow_Paper,			// 0x14.
	Camouflage_Paper,	// 0x15.
	Hamburger_Paper,	// 0x16.
	Piano_Paper,		// 0x17.
	Nook_Paper,			// 0x18.
	Fox_Paper,			// 0x19.
	Birthday_Cards,		// 0x1A.
	Four_leaf_Paper,	// 0x1B.
	Town_hall_Paper,	// 0x1C.
	Tortimer_Paper,		// 0x1D.
	Insurance_Paper,	// 0x1E.
	Academy_Paper,		// 0x1F.
	Lovely_Paper,		// 0x20.
	Rainbow_Paper,		// 0x21.
	Egyptian_Paper,		// 0x22.
	Lotus_Paper,		// 0x23.
	Tile_Paper,			// 0x24.
	Mosaic_Paper,		// 0x25.
	Elegant_Paper,		// 0x26.
	Town_View_Paper,	// 0x27.
	Chinese_Paper,		// 0x28.
	Ocean_Paper,		// 0x29.
	Industrial_Paper,	// 0x2A.
	Fireworks_Paper,	// 0x2B.
	Floral_Paper,		// 0x2C.
	Mushroom_Paper,		// 0x2D.
	Star_Paper,			// 0x2E.
	Composer_Paper,		// 0x2F.
	Bathtub_Paper,		// 0x30.
	SMB3_Paper,			// 0x31.
	Cool_Paper,			// 0x32.
	Forest_Paper,		// 0x33.
	Bubble_Paper,		// 0x34.
	Buttercup_Paper,	// 0x35.
	Tartan_Paper,		// 0x36.
	Plaid_Paper,		// 0x37.
	Lemon_lime_Paper,	// 0x38.
	Crater_Paper,		// 0x39.
	Bejeweled_Paper,	// 0x3A.
	Geometric_Paper,	// 0x3B.
	Southwest_Paper,	// 0x3C.
	Night_Sky_Paper,	// 0x3D.
	Chic_Paper,			// 0x3E.
	Goldfish_Paper		// 0x3F.
};

/*
	AC:WW Letter Flags, which got figured out.
	NOTE: THIS MAY NOT BE CORRECT, MORE RESEARCH NEEDED.
*/
enum class LetterFlags : uint8_t {
	Not_Existent,			// 0x0.
	Created,				// 0x1.
	Unread,					// 0x2.
	Read,					// 0x3.
	BottleLetterReceived,	// 0x4.
	BottleLetterSend,		// 0x5.

	/*
		Note: Are the last two really correct?
		It seems more like 0x40 + Unread / Read flag.
	*/

	Mother_Unread,			// 0x42.
	Mother_Read				// 0x43.
};

/*
	AC:WW Letter Struct [EUR | USA].
	Size: 0xF4.

	Bytes left to research: 0x4 + 0x1 + 0x6 --> 0xB.
*/
struct EUR_USA_LETTER {
	uint16_t TownIDReceiver; // 0x0 - 0x1.
	uint8_t TownNameReceiver[0x8]; // 8 Characters is the limit. 0x2 - 0x9.
	uint16_t PlayerIDReceiver; // 0xA - 0xB.
	uint8_t PlayerNameReceiver[0x8]; // 0xC - 0x13.
	uint16_t TownIDSender; // 0x18 - 0x19.
	uint8_t TownNameSender[0x8]; // 8 Characters is the limit. 0x1A - 0x21.
	uint16_t PlayerIDSender; // 0x22 - 0x23.
	uint8_t PlayerNameSender[0x8]; // 8 Characters is the limit. 0x24 - 0x2B.
	uint8_t Unresearched1[0x4]; // 0x2C - 0x2F.
	uint8_t Intro[0x18]; // 24 Characters is the limit. 0x30 - 0x47.
	uint8_t Body[0x81]; // 129 Characters is the limit. 0x48 - 0xC7.
	uint8_t End[0x20]; // 32 Characters is the limit. 0xC8 - 0xE7.
	uint8_t IntroNamePosition; // 0xE8.
	PaperIDs PaperID; // 0xE9.
	LetterFlags LetterFlag; // 0xEA.
	uint8_t Unresearched2; // 0xEB.
	uint16_t Item; // 0xEC - 0xED.
	uint8_t Unresearched3[0x6]; // 0xEE - 0xF3.
};


/*
	AC:WW Letter Struct [JPN].
	Size: 0x8C.

	Bytes left to research: 0x3 + 0x4 + 0x1 + 0x4 --> 0xC.
*/
struct JPN_LETTER {
	uint16_t TownIDReceiver; // 0x0 - 0x1.
	uint8_t TownNameReceiver[0x6]; // 6 Characters is the limit. 0x2 - 0x7.
	uint16_t PlayerIDReceiver; // 0x8 - 0x9.
	uint8_t PlayerNameReceiver[0x6]; // 0xA - 0xF.
	uint8_t Unresearched1[0x3]; // 0x10 - 0x13.
	uint16_t TownIDSender; // 0x14 - 0x15.
	uint8_t TownNameSender[0x6]; // 6 Characters is the limit. 0x16 - 0x1B.
	uint16_t PlayerIDSender; // 0x1C - 0x1D.
	uint8_t PlayerNameSender[0x6]; // 6 Characters is the limit. 0x1E - 0x23.
	uint8_t Unresearched2[0x4]; // 0x24 - 0x27.
	uint8_t Intro[0xA]; // 10 Characters is the limit. 0x28 - 0x31.
	uint8_t Body[0x40]; // 64 Characters is the limit. 0x32 - 0x71.
	uint8_t End[0x10]; // 16 Characters is the limit. 0x72 - 0x81.
	uint8_t IntroNamePosition; // 0x82.
	PaperIDs PaperID; // 0x83.
	LetterFlags LetterFlag; // 0x84.
	uint8_t Unresearched3; // 0x85.
	uint16_t Item; // 0x86 - 0x87.
	uint8_t Unresearched4[0x4]; // 0x88 - 0x8B.
};


/*
	AC:WW Letter Struct [KOR].
	Size: 0x100.

	Bytes left to research: 0x4 + 0x4 + 0x1 + 0x6 --> 0xF.
*/
struct KOR_LETTER {
	uint16_t TownIDReceiver; // 0x0 - 0x1.
	char16_t TownNameReceiver[6]; // 6 Characters is the limit. 0x2 - 0xD.
	uint16_t PlayerIDReceiver; // 0xE - 0xF.
	char16_t PlayerNameReceiver[6]; // 6 Characters is the limit. 0x10 - 0x1B.
	uint8_t Unresearched1[0x4]; // 0x1C - 0x1F.
	uint16_t TownIDSender; // 0x20 - 0x21.
	char16_t TownNameSender[6]; // 6 Characters is the limit. 0x22 - 0x2D.
	uint16_t PlayerIDSender; // 0x2E - 0x2F.
	char16_t PlayerNameSender[6]; // 6 Characters is the limit. 0x30 - 0x3B.
	uint8_t Unresearched2[0x4]; // 0x3C - 0x3F.
	char16_t Intro[10]; // 10 Characters is the limit. 0x40 - 0x53.
	char16_t Body[64]; // 64 Characters is the limit. 0x54 - 0xD3.
	char16_t End[16]; // 16 Characters is the limit. 0xD4 - 0xF3.
	uint8_t IntroNamePosition; // 0xF4.
	PaperIDs PaperID; // 0xF5.
	LetterFlags LetterFlag; // 0xF6
	uint8_t Unresearched3; // 0xF7.
	uint16_t Item; // 0xF8 - 0xF9.
	uint8_t Unresearched4[0x6]; // 0xFA - 0xFF.
};

/*
	Letter Storage Notes:
		EUR | USA:
			- Startoffset: 0x2E210 - 0x3FFFF.
			- Size: 0x11DF0.
			- Letters per player: 75.

		JPN:
			- Startoffset: 0x35BF0 - 0x3FFFF.
			- Size: 0xA410.
			- Letters per player: 75.

		KOR:
			- Startoffset: 0x33800 - 0x3FFFF.
			- Size: 0xC800.
			- Letters per player: 50.

		NOTE: When storing letters there, both savecopy's last 3 bytes are different.
		TODO: Figure out what's going on there.
*/